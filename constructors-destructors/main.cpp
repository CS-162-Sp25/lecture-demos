#include <iostream>

// What is the purpose of a constructor?
// A: To initialize / set up an object. Called automatically when object is declared.

// Rule about constructors:
// A default constructor will automatically be generated by your compiler
// if no constructors have been explicitly declared for that class.
// It does nothing.

// The Big Three are:
// Destructors
// Copy constructors
// Copy assignment operator overloads (assignment operator overloads, AOO)

// What is the purpose of a destructor?
// A: To "tear down" an object
//
// Destructor is called automatically whenever an object is freed from memory
// Commonly frees the memory associaterd with the object's dynamically allocated
// 	member variables

class pet {
private:
	std::string name;
	int age;
public:
	pet(const std::string& name, int age);
};

pet::pet(const std::string& name, int age) : name(name), age(age) {
	std::cout << "Pet constructor!" << std::endl;
}

// pet_owner.hpp
// Member variables denote a "has-a" relationship
class pet_owner {
private:
	int num_pets;
	std::string* pet_names;
	pet favorite_pet;
public:
	void print() const;
	// pet_owner(); // Default constructor: Constructor with no parameters
	pet_owner();
	pet_owner(int num_pets); // Nondefault constructor: Constructor with parameters
	pet_owner(const pet_owner& other); // Copy constructor
	pet_owner& operator=(const pet_owner& other);

	~pet_owner(); // Destructor
};

// pet_owner.cpp
void pet_owner::print() const {
	for (int i = 0; i < this->num_pets; i++) {
		std::cout << this->pet_names[i] << std::endl;
	}
}

// Default constructor
pet_owner::pet_owner() : num_pets(0), pet_names(nullptr), favorite_pet("NULL", 0) {
	std::cout << "Default Constructor!" << std::endl;
}

// Nondefault constructor
pet_owner::pet_owner(int num_pets) : num_pets(num_pets), pet_names(new std::string[this->num_pets]), favorite_pet("Jeff", 5) {
	std::cout << "Nondefault constructor!" << std::endl;
}

pet_owner::pet_owner(const pet_owner& other) :
		num_pets(other.num_pets),
		pet_names(new std::string[other.num_pets]),
		favorite_pet(other.favorite_pet) {
	for (int i = 0; i < this->num_pets; i++) {
		this->pet_names[i] = other.pet_names[i];
	}
	std::cout << "Copy constructor!" << std::endl;
}

pet_owner::~pet_owner() {
	delete [] this->pet_names;
	std::cout << "Destructor!" << std::endl;
}

pet_owner& pet_owner::operator=(const pet_owner& other) {
	if (this == &other) {
		return *this;
	}

	this->num_pets = other.num_pets;
	delete [] this->pet_names;
	this->pet_names = new std::string[other.num_pets];
	this->favorite_pet = other.favorite_pet; // This line of code calls the AOO of the pet class. That's fine.
	for (int i = 0; i < this->num_pets; i++) {
		this->pet_names[i] = other.pet_names[i];
	}
	std::cout << "AOO!" << std::endl;

	return *this;
}


// Any time you create a class with a member variable that is a pointer
// that is meant to point to dynamic memory, you should create the big 3
// for that class to manages that dynamic memory

// main.cpp
int main() {
	pet_owner p; // This line calls the DEFAULT constructor
	// Initialize, or "set up" p, including ALL of its member variables
	
	p.print();

	pet_owner p2(5);

	/*
	pet_owner owners[10];
	int n;
	std::cin >> n;
	pet_owner* owners_heap = new pet_owner[n];
	*/

	pet_owner p3 = p2;
	// Copies member variables from p2 to p3
	
	// Shallow copy
	// pet_owner p3;
	// p3.num_pets = p2.num_pets;
	// p3.pet_names = p2.pet_names;
	// // p3.favorite_pet = p2.favorite_pet;
	// 	p3.favorite_pet.name = p2.favorite_pet.name;
	// 	p3.favorite_pet.age = p2.favorite_pet.age;
	
	// This is problematic
	
	// Problem 1: If we were to modify an element within p2.pet_names, that would
	// also modify the same element in p3.pet_names (and vice-versa)
	
	// Problem 2: Double free on destructor calls

	// Deep copy: Rather than copying surface-level pointers, create NEW
	// pointers that point to NEW arrays, and then initialize the data
	// within those NEW arrays to "look identical" to the data in the
	// object's corresponding arrays
	
	// If you don't define a copy constructor for a class, the compiler
	// will automatically generate one for you that does a shallow copy

	p3 = p2; // This calls the copy assignment operator

	// If you don't define a copy assignment operator overload (AOO)
	// for your class, the compiler will automatically generate one for you
	// that does a shallow copy
}
